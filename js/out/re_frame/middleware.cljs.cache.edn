;; Analyzed by ClojureScript 0.0-3058
{:use-macros nil, :excludes #{}, :name re-frame.middleware, :imports nil, :requires {data clojure.data, clojure.data clojure.data, re-frame.utils re-frame.utils, re-frame.undo re-frame.undo, reagent.ratom reagent.ratom}, :uses {groupEnd re-frame.utils, log re-frame.utils, IReactiveAtom reagent.ratom, dbg re-frame.utils, group re-frame.utils, warn re-frame.utils, store-now! re-frame.undo}, :defs {after {:protocol-inline nil, :meta {:arglists (quote ([f])), :doc "Middleware factory which runs a function \"f\" in the \"after handler\"\n  position presumably for side effects.\n  \"f\" is given the value of \"db\". It's return value is ignored.\n  Examples: \"f\" can run schema validation. Or write current state to localstorage. etc.\n  In effect, \"f\" is meant to sideeffect. It gets no chance to change db. See \"enrich\"\n  (if you need that.)", :end-column 12, :end-line 139, :column 7, :line 139, :file "/Users/rsslldnphy/Code/russellfail/resources/public/js/out/re_frame/middleware.cljs"}, :name re-frame.middleware/after, :variadic false, :file "resources/public/js/out/re_frame/middleware.cljs", :end-column 12, :method-params ([f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1}), :line 139, :end-line 139, :max-fixed-arity 1, :fn-var true, :arglists (quote ([f])), :doc "Middleware factory which runs a function \"f\" in the \"after handler\"\n  position presumably for side effects.\n  \"f\" is given the value of \"db\". It's return value is ignored.\n  Examples: \"f\" can run schema validation. Or write current state to localstorage. etc.\n  In effect, \"f\" is meant to sideeffect. It gets no chance to change db. See \"enrich\"\n  (if you need that.)", :test true}, enrich {:protocol-inline nil, :meta {:arglists (quote ([f])), :doc "Middleware factory which runs a given function \"f\" in the after position.\n  \"f\" is (db) -> db\n  Unlike \"after\" which is about side effects, \"enrich\" expects f to process and alter\n  db in some useful way, contributing to the derived data, flowing vibe.\n  Imagine that todomvc needed to do duplicate detection - if any two todos had\n  the same text, then highlight their background, and report them in a warning\n  down the bottom.\n  Almost any action (edit text, add new todo, remove a todo) requires a\n  complete reassesment of duplication errors and warnings. Eg: that edit\n  update might have introduced a new duplicate or removed one. Same with a\n  todo removal.\n  And to perform this enrichment, a function has inspect all the todos,\n  possibly set flags on each, and set some overall list of duplicates.\n  And this duplicates checking might be just one check amoung a number.\n  \"f\" would need to be both adding and removing the duplicate warnings.\n  By applying \"f\" in middleware, we keep the handlers simple and yet we\n  ensure this important step is not missed. ", :end-column 13, :end-line 112, :column 7, :line 112, :file "/Users/rsslldnphy/Code/russellfail/resources/public/js/out/re_frame/middleware.cljs"}, :name re-frame.middleware/enrich, :variadic false, :file "resources/public/js/out/re_frame/middleware.cljs", :end-column 13, :method-params ([f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1}), :line 112, :end-line 112, :max-fixed-arity 1, :fn-var true, :arglists (quote ([f])), :doc "Middleware factory which runs a given function \"f\" in the after position.\n  \"f\" is (db) -> db\n  Unlike \"after\" which is about side effects, \"enrich\" expects f to process and alter\n  db in some useful way, contributing to the derived data, flowing vibe.\n  Imagine that todomvc needed to do duplicate detection - if any two todos had\n  the same text, then highlight their background, and report them in a warning\n  down the bottom.\n  Almost any action (edit text, add new todo, remove a todo) requires a\n  complete reassesment of duplication errors and warnings. Eg: that edit\n  update might have introduced a new duplicate or removed one. Same with a\n  todo removal.\n  And to perform this enrichment, a function has inspect all the todos,\n  possibly set flags on each, and set some overall list of duplicates.\n  And this duplicates checking might be just one check amoung a number.\n  \"f\" would need to be both adding and removing the duplicate warnings.\n  By applying \"f\" in middleware, we keep the handlers simple and yet we\n  ensure this important step is not missed. ", :test true}, undoable {:protocol-inline nil, :meta {:arglists (quote ([explanation])), :doc "A Middleware factory which stores an undo checkpoint.\n  \"explanation\" can be either a string or a function. If it is a\n  function then must be:  (db event-vec) -> string.\n  \"explanation\" can be nil. in which case \"\" is recorded.\n  ", :end-column 15, :end-line 92, :column 7, :line 92, :file "/Users/rsslldnphy/Code/russellfail/resources/public/js/out/re_frame/middleware.cljs"}, :name re-frame.middleware/undoable, :variadic false, :file "resources/public/js/out/re_frame/middleware.cljs", :end-column 15, :method-params ([explanation]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1}), :line 92, :end-line 92, :max-fixed-arity 1, :fn-var true, :arglists (quote ([explanation])), :doc "A Middleware factory which stores an undo checkpoint.\n  \"explanation\" can be either a string or a function. If it is a\n  function then must be:  (db event-vec) -> string.\n  \"explanation\" can be nil. in which case \"\" is recorded.\n  ", :test true}, path {:protocol-inline nil, :meta {:arglists (quote ([& args])), :doc "A middleware factory which supplies a sub-tree of `db` to the handler.\n  Works a bit like update-in. Supplies a narrowed data structure for the handler.\n  Afterwards, grafts the result of the handler back into db.\n  Usage:\n     (path :some :path)\n     (path [:some :path])\n     (path [:some :path] :to :here)\n     (path [:some :path] [:to] :here)\n  ", :end-column 11, :end-line 71, :column 7, :line 71, :file "/Users/rsslldnphy/Code/russellfail/resources/public/js/out/re_frame/middleware.cljs"}, :name re-frame.middleware/path, :variadic true, :file "resources/public/js/out/re_frame/middleware.cljs", :end-column 11, :method-params ([args]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag function, :variadic true, :max-fixed-arity 0}), :line 71, :end-line 71, :max-fixed-arity 0, :fn-var true, :arglists (quote ([& args])), :doc "A middleware factory which supplies a sub-tree of `db` to the handler.\n  Works a bit like update-in. Supplies a narrowed data structure for the handler.\n  Afterwards, grafts the result of the handler back into db.\n  Usage:\n     (path :some :path)\n     (path [:some :path])\n     (path [:some :path] :to :here)\n     (path [:some :path] [:to] :here)\n  ", :test true}, trim-v {:protocol-inline nil, :meta {:arglists (quote ([handler])), :doc "Middleware which removes the first element of v, allowing you to write\n  more asthetically pleasing handlers. No leading underscore on the event-v!\n  Your handlers will look like this:\n      (defn my-handler\n        [db [x y z]]    ;; <-- instead of [_ x y z]\n        ....)\n  ", :end-column 13, :end-line 57, :column 7, :line 57, :file "/Users/rsslldnphy/Code/russellfail/resources/public/js/out/re_frame/middleware.cljs"}, :name re-frame.middleware/trim-v, :variadic false, :file "resources/public/js/out/re_frame/middleware.cljs", :end-column 13, :method-params ([handler]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1}), :line 57, :end-line 57, :max-fixed-arity 1, :fn-var true, :arglists (quote ([handler])), :doc "Middleware which removes the first element of v, allowing you to write\n  more asthetically pleasing handlers. No leading underscore on the event-v!\n  Your handlers will look like this:\n      (defn my-handler\n        [db [x y z]]    ;; <-- instead of [_ x y z]\n        ....)\n  ", :test true}, debug {:protocol-inline nil, :meta {:arglists (quote ([handler])), :doc "Middleware which logs debug information to js/console for each event.\n  Includes a clojure.data/diff of the db, before vs after, showing the changes\n  caused by the event.", :end-column 12, :end-line 40, :column 7, :line 40, :file "/Users/rsslldnphy/Code/russellfail/resources/public/js/out/re_frame/middleware.cljs"}, :name re-frame.middleware/debug, :variadic false, :file "resources/public/js/out/re_frame/middleware.cljs", :end-column 12, :method-params ([handler]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1}), :line 40, :end-line 40, :max-fixed-arity 1, :fn-var true, :arglists (quote ([handler])), :doc "Middleware which logs debug information to js/console for each event.\n  Includes a clojure.data/diff of the db, before vs after, showing the changes\n  caused by the event.", :test true}, pure {:protocol-inline nil, :meta {:arglists (quote ([handler])), :doc "Acts as an adaptor, allowing handlers to be writen as pure functions.\n  The re-frame router passes the `app-db` atom as the first parameter to any handler.\n  This middleware adapts that atom to be the value within the atom.\n  If you strip away the error/efficiency checks, this middleware is doing:\n     (reset! app-db (handler @app-db event-vec))\n  You don't have to use this middleware directly. It is automatically applied to\n  your handler's middleware when you use \"register-handler\".\n  In fact, the only way to by-pass automatic use of \"pure\" in your middleware\n  is to use the low level registration function \"re-frame.handlers/register-handler-base\"", :end-column 11, :end-line 13, :column 7, :line 13, :file "/Users/rsslldnphy/Code/russellfail/resources/public/js/out/re_frame/middleware.cljs"}, :name re-frame.middleware/pure, :variadic false, :file "resources/public/js/out/re_frame/middleware.cljs", :end-column 11, :method-params ([handler]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag function, :variadic false, :max-fixed-arity 1}), :line 13, :end-line 13, :max-fixed-arity 1, :fn-var true, :arglists (quote ([handler])), :doc "Acts as an adaptor, allowing handlers to be writen as pure functions.\n  The re-frame router passes the `app-db` atom as the first parameter to any handler.\n  This middleware adapts that atom to be the value within the atom.\n  If you strip away the error/efficiency checks, this middleware is doing:\n     (reset! app-db (handler @app-db event-vec))\n  You don't have to use this middleware directly. It is automatically applied to\n  your handler's middleware when you use \"register-handler\".\n  In fact, the only way to by-pass automatic use of \"pure\" in your middleware\n  is to use the low level registration function \"re-frame.handlers/register-handler-base\"", :test true}}, :require-macros nil, :cljs.analyzer/constants {:order [:else], :seen #{:else}}, :doc nil}